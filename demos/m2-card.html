<!DOCTYPE html>
<!--
  Copyright 2016 Google Inc. All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License
-->
<html class="mdc-typography">
  <head>
    <meta charset="utf-8">
    <title>M2 Card Prototype - Material Components Catalog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="/images/logo_components_color_2x_web_48dp.png">
    <script src="/assets/m2-card.css.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  </head>

  <body>
    <header class="mdc-toolbar mdc-toolbar--fixed">
      <div class="mdc-toolbar__row">
        <section class="mdc-toolbar__section mdc-toolbar__section--align-start">
          <span class="catalog-back">
            <a href="/" class="mdc-toolbar__menu-icon"><i class="material-icons">&#xE5C4;</i></a>
          </span>
          <span class="mdc-toolbar__title catalog-title">M2 Card Prototype</span>
        </section>
      </div>
    </header>

    <main>
      <div class="mdc-toolbar-fixed-adjust"></div>
      <section class="hero">
        <div class="m2-card-group demo-card-group">
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">1</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">2</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">3</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">4</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">5</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">6</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">7</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">8</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">9</div>
        </div>
        <div class="m2-card-group demo-card-group">
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">1</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">2</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">3</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">4</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">5</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">6</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">7</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">8</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">9</div>
        </div>
      </section>
    </main>

    <script src="/assets/material-components-web.js"></script>
    <script src="/lib/draggable/1.0.0-beta.3/draggable.bundle.patched.js"></script>
    <script>
      (() => {
        class Card {
          constructor(element) {
            this.element = element;
            this.viewportRect = element.getBoundingClientRect();
          }

          isDragSource() {
            return this.element.hasAttribute('aria-grabbed');
          }

          static create(element) {
            return new Card(element);
          }

          static isVisible(card) {
            return card.viewportRect.width > 0 && card.viewportRect.height > 0;
          }

          static orderByCoordinate(firstCard, secondCard) {
            const topDelta = firstCard.viewportRect.top - secondCard.viewportRect.top;
            const leftDelta = firstCard.viewportRect.left - secondCard.viewportRect.left;
            return topDelta || leftDelta;
          }
        }

        /** Represents an area where a card can be dropped. */
        class DropZone {
          // TODO(acdvorak): Rename nextCard to something better?
          constructor(
            nextCard, {toleranceInPx = 50, rowIndex, colIndex, rowGapInPx = 0, colGapInPx = 0, spacerWidth = 0} = {}) {
            this.nextCard = nextCard;
            this.rowIndex = rowIndex;
            this.colIndex = colIndex;
            this.toleranceInPx = toleranceInPx;
            this.colGapInPx = colGapInPx;
            this.rowGapInPx = rowGapInPx;
            this.spacerWidth = spacerWidth;

            this.viewportRect = {
              top: nextCard.viewportRect.top - (this.rowGapInPx / 2),
              bottom: nextCard.viewportRect.bottom + (this.rowGapInPx / 2),

              // TODO(acdvorak): Compute this dynamically from the margins between cards
              left: nextCard.viewportRect.left - this.colGapInPx,
              right: nextCard.viewportRect.left,
            };

            Object.assign(this.viewportRect, {
              height: this.viewportRect.bottom - this.viewportRect.top,
              width: this.viewportRect.right - this.viewportRect.left,
            })
          }

          // TODO(acdvorak): Handle jank that occurs when mouse is right on the edge of drop zone.
          // Inserting the drop zone element changes the positioning.
          intersectsViewportPoint(viewportPoint) {
            // Point is above the gap.
            if (viewportPoint.y < this.viewportRect.top) {
              return false;
            }

            // Point is below the gap.
            if (viewportPoint.y > this.viewportRect.bottom) {
              return false;
            }

            // Point is left of the gap.
            if (viewportPoint.x < this.viewportRect.left - this.toleranceInPx) {
              return false;
            }

            // Point is right of the gap.
            if (viewportPoint.x > this.viewportRect.right + this.toleranceInPx) {
              return false;
            }

            return true;
          }
        }

        function isAdjacentToDragSource(curRow, colIndex) {
          if (curRow[colIndex].isDragSource()) {
            return true;
          }
          if (curRow[colIndex - 1] && curRow[colIndex - 1].isDragSource()) {
            return true;
          }
          return false;
        }

        function getColGapInPx(rows) {
          if (rows.length < 1 || rows[0].length < 2) {
            return 0;
          }
          const firstRow = rows[0];
          return firstRow[1].viewportRect.left - firstRow[0].viewportRect.right;
        }

        function getRowGapInPx(rows) {
          if (rows.length < 2) {
            return 0;
          }
          const firstRow = rows[0];
          const secondRow = rows[1];
          return secondRow[0].viewportRect.top - firstRow[0].viewportRect.bottom;
        }

        function getSpacerWidth(cardGroupEl, rows, rowIndex, colIndex) {
          if (rowIndex === 0 || colIndex > 0) {
            return 0;
          }

          const cardGroupRight = cardGroupEl.getBoundingClientRect().right;
          const prevRow = rows[rowIndex - 1];
          const prevRowLastCard = prevRow[prevRow.length - 1];

          // TODO(acdvorak): Don't assume px units
          const prevRowLastCardMarginRight = parseInt(getComputedStyle(prevRowLastCard.element).marginRight, 10);
          const prevRowLastCardRight = prevRowLastCard.viewportRect.right + prevRowLastCardMarginRight;

          return cardGroupRight - prevRowLastCardRight;
        }

        function getPointerPositionInViewport(e) {
          const originalEvent = e.originalEvent;
          const nativePointerEvent = originalEvent.touches ? originalEvent.touches[0] : originalEvent;
          return {
            x: nativePointerEvent.clientX,
            y: nativePointerEvent.clientY,
          };
        }

        function getCards(e) {
          const cardGroupEl = e.originalSource.closest('.m2-card-group');
          const cardEls = [].slice.call(cardGroupEl.querySelectorAll('.m2-card'));
          cardEls.forEach((cardEl) => {
            cardEl.style.transform = '';
          });
          const cards = cardEls
            .map(Card.create)
            .filter(Card.isVisible)
            .sort(Card.orderByCoordinate);

          const rowBuckets = new Map();
          cards.forEach((card) => {
            const top = card.viewportRect.top;
            if (!rowBuckets.has(top)) {
              rowBuckets.set(top, []);
            }
            rowBuckets.get(top).push(card);
            card.element.style.transform = '';
          });

          const rows = [];
          rowBuckets.forEach((row) => {
            rows.push(row);
          });

          return {cardGroupEl, cardEls, rows};
        }

        function getDropZone(e, {rowGapInPx, colGapInPx} = {}) {
          const pointerPositionInViewport = getPointerPositionInViewport(e);
          const {cardGroupEl, rows} = getCards(e);

          const dropZones = [];
          rows.forEach((curRow, rowIndex) => {
            curRow.forEach((curCardInRow, colIndex) => {
              if (isAdjacentToDragSource(curRow, colIndex)) {
                return;
              }
              dropZones.push(new DropZone(curCardInRow, {
                toleranceInPx: curCardInRow.viewportRect.width / 2,
                spacerWidth: getSpacerWidth(cardGroupEl, rows, rowIndex, colIndex),
                rowGapInPx,
                colGapInPx,
                rowIndex,
                colIndex,
              }));
            });
          });

          let activeDropZone = false;
          for (let curDropZone of dropZones) {
            if (curDropZone.intersectsViewportPoint(pointerPositionInViewport)) {
              activeDropZone = curDropZone;
              break;
            }
          }

          return activeDropZone;
        }

        var interval = setInterval(() => {
          if (getComputedStyle(document.querySelector('.hero')).position === 'relative') {
            clearInterval(interval);
            init();
          }
        }, 200);

        // NOTE(acdvorak): This code assumes:
        // 1. ALL CARDS ARE THE SAME SIZE
        // 2. HORIZONTAL AND VERTICAL MARGINS BETWEEN CARDS ARE IDENTICAL
        // TODO(acdvorak): RTL support
        function init() {
          var cards = document.querySelectorAll('.m2-card');
          for (var i = 0; i < cards.length; i++) {
            let card = cards[i];
            // TODO(acdvorak): This is gross
            card.ripple = mdc.ripple.MDCRipple.attachTo(card);
          }

          const draggable = new Draggable.Draggable(document.querySelectorAll('.demo-card-group'), {
            draggable: '.m2-card',
            delay: 200,
            classes: {
              'container:dragging': 'm2-card-group--dragging',
              'source:dragging': 'm2-card--drag-source',
              'mirror': 'm2-card--drag-mirror',
            },
          });

          const dropZoneElDummyParent = document.createElement('div');
          dropZoneElDummyParent.innerHTML = `
<div class="m2-card-drop-spacer"></div>
<div class="m2-card-drop-zone"></div>
          `.trim();
          const dropSpacerEl = dropZoneElDummyParent.children[0];
          const dropZoneEl = dropZoneElDummyParent.children[1];

          let colGapInPx;
          let rowGapInPx;
          let dropZone;
          let sourceCardEl;

          draggable.on('drag:start', (e) => {
            const {rows} = getCards(e);

            colGapInPx = getColGapInPx(rows);
            rowGapInPx = getRowGapInPx(rows);
            dropZone = null;
            sourceCardEl = e.originalSource;
          });

          draggable.on('drag:move', (e) => {
            const {rows} = getCards(e);
            dropZone = getDropZone(e, {rowGapInPx, colGapInPx});

            dropSpacerEl.remove();
            dropZoneEl.remove();

            e.originalEvent.preventDefault();

            if (dropZone) {
              dropZone.nextCard.element.insertAdjacentElement('beforebegin', dropZoneEl);
              if (dropZone.spacerWidth) {
                dropZoneEl.insertAdjacentElement('beforebegin', dropSpacerEl);
                dropSpacerEl.style.width = dropZone.spacerWidth + 'px';
              } else {
                dropSpacerEl.remove();
                dropSpacerEl.style.width = '0';
              }

              const curRow = rows[dropZone.rowIndex];
              curRow.forEach((curCardInRow, curCardInRowColIndex) => {
                let mult = +1;
                if (curCardInRowColIndex < dropZone.colIndex) {
                  mult = -1;
                }
                const offsetX = mult * (dropZone.colGapInPx / 2);
                curCardInRow.element.style.transform = `translateX(${offsetX}px)`;
              });
            } else {
              dropSpacerEl.remove();
              dropZoneEl.remove();
            }
          });

          draggable.on('drag:stop', (e) => {
            const {cardEls} = getCards(e);

            cardEls.forEach((cardEl) => {
              cardEl.style.transform = '';
            });

            if (dropZone) {
              const nextCardEl = dropZone.nextCard.element;
              const dragSourceEl = e.originalSource;
              setTimeout(() => {
                nextCardEl.insertAdjacentElement('beforebegin', dragSourceEl);
              });
            }

            dropSpacerEl.remove();
            dropZoneEl.remove();

            if (sourceCardEl.ripple) {
              // TODO(acdvorak): Submit PR to "draggable" repo to pass through originalEvent to drag:stop
              // TODO(acdvorak): Submit PR to "draggable" repo to listen for ESC key
//              sourceCardEl.ripple.deactivate(e.originalEvent);

              // TODO(acdvorak): Submit PR to fix Ripple so that it doesn't require an event object
              sourceCardEl.ripple.deactivate({type: 'pointerup'});
            }

            colGapInPx = 0;
            rowGapInPx = 0;
            dropZone = null;
            sourceCardEl = null;
          });
        }
      })();
    </script>
  </body>
</html>
