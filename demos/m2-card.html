<!DOCTYPE html>
<!--
  Copyright 2016 Google Inc. All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License
-->
<html class="mdc-typography">
  <head>
    <meta charset="utf-8">
    <title>M2 Card Prototype - Material Components Catalog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="/images/logo_components_color_2x_web_48dp.png">
    <script src="/assets/m2-card.css.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  </head>

  <body>
    <header class="mdc-toolbar mdc-toolbar--fixed">
      <div class="mdc-toolbar__row">
        <section class="mdc-toolbar__section mdc-toolbar__section--align-start">
          <span class="catalog-back">
            <a href="/" class="mdc-toolbar__menu-icon"><i class="material-icons">&#xE5C4;</i></a>
          </span>
          <span class="mdc-toolbar__title catalog-title">M2 Card Prototype</span>
        </section>
      </div>
    </header>

    <main>
      <div class="mdc-toolbar-fixed-adjust"></div>
      <section class="hero">
        <div class="m2-card-group demo-card-group">
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">1</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">2</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">3</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">4</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">5</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">6</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">7</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">8</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--grey" tabindex="0">9</div>
        </div>
        <div class="m2-card-group demo-card-group" dir="rtl">
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">1</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">2</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">3</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">4</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">5</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">6</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">7</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">8</div>
          <div class="m2-card mdc-ripple-surface demo-card demo-card--color" tabindex="0">9</div>
        </div>
      </section>
    </main>

    <script src="/assets/material-components-web.js"></script>
    <script src="/lib/draggable/1.0.0-beta.3/draggable.bundle.patched.js"></script>
    <script>
      (() => {
        /** @enum {string} */
        const CardSide = {
          LEFT: 'left',
          RIGHT: 'right',
        };

        const Directionality = {
          LTR: 'ltr',
          RTL: 'rtl',
        };

        function getDirectionality(element) {
          const ancestor = element.closest('[dir]');
          return ancestor && ancestor.getAttribute('dir') === Directionality.RTL
              ? Directionality.RTL
              : Directionality.LTR;
        }

        function isRTL(element) {
          return getDirectionality(element) === Directionality.RTL;
        }

        function isLTR(element) {
          return !isRTL(element);
        }

        function getOffsetParent(element) {
          if (element.offsetParent) {
            return element.offsetParent;
          }

          const displayNoneElements = [];
          const inlineDisplayValues = [];

          // Find all hidden ancestor elements.
          let curEl = element;
          while (curEl) {
            if (getComputedStyle(curEl).display === 'none') {
              displayNoneElements.push(curEl);
              inlineDisplayValues.push(curEl.style.display);
            }
            curEl = curEl.parentElement;
          }

          // Temporarily show all hidden ancestor elements.
          displayNoneElements.forEach((displayNoneEl) => {
            displayNoneEl.style.display = 'block';
          });

          const offsetParent = element.offsetParent;

          // Restore `display` to its original value.
          displayNoneElements.forEach((displayNoneEl, idx) => {
            displayNoneEl.style.display = inlineDisplayValues[idx];
          });

          return offsetParent;
        }

        function getOffset(elementRect, parentRect) {
          const offsetRect = {};
          offsetRect.top = offsetRect.y = elementRect.top - parentRect.top;
          offsetRect.left = offsetRect.x = elementRect.left - parentRect.left;
          offsetRect.right = offsetRect.left + elementRect.width;
          offsetRect.bottom = offsetRect.top + elementRect.height;
          offsetRect.width = elementRect.width;
          offsetRect.height = elementRect.height;
          return offsetRect;
        }

        function getOffsetFromParent(element) {
          const elementViewportRect = element.getBoundingClientRect();
          const parentViewportRect = getOffsetParent(element).getBoundingClientRect();
          return getOffset(elementViewportRect, parentViewportRect);
        }

        class Card {
          constructor(element) {
            this.element = element;
            this.parentOffsetRect = getOffsetFromParent(element);
            this.offsetX_ = 0;
          }

          get offsetX() {
            return this.offsetX_;
          }

          set offsetX(offsetX) {
            this.offsetX_ = offsetX;
            // TODO(acdvorak): Find a way to do this that won't prevent clients from being able to use `transform`.
            this.element.style.transform = this.offsetX_ ? `translateX(${this.offsetX_}px)` : '';
          }

          isDragSource() {
            return this.element.hasAttribute('aria-grabbed');
          }

          static create(element) {
            return new Card(element);
          }

          static isVisible(card) {
            return card.parentOffsetRect.width > 0 && card.parentOffsetRect.height > 0;
          }

          static orderByCoordinate(firstCard, secondCard) {
            const topDelta = firstCard.parentOffsetRect.top - secondCard.parentOffsetRect.top;
            const leftDelta = firstCard.parentOffsetRect.left - secondCard.parentOffsetRect.left;
            return topDelta || leftDelta;
          }
        }

        /** Represents an area where a card can be dropped. */
        class DropZone {
          // TODO(acdvorak): Rename adjacentCard to something better?
          constructor({adjacentCard, cardSide, allRows, rowIndex, colIndex, rowGapInPx, colGapInPx,
                       toleranceInPx = 50} = {}) {
            this.adjacentCard = adjacentCard;
            this.cardSide = cardSide;
            this.allRows = allRows;
            this.rowIndex = rowIndex;
            this.colIndex = colIndex;
            this.toleranceInPx = toleranceInPx;
            this.colGapInPx = colGapInPx;
            this.rowGapInPx = rowGapInPx;
            this.parentOffsetRect = this.calculateParentOffsetRect();
          }

          calculateParentOffsetRect() {
            const adjacentCardParentOffsetRect = this.adjacentCard.parentOffsetRect;
            const parentOffsetRect = {};
            parentOffsetRect.top = parentOffsetRect.y = adjacentCardParentOffsetRect.top - (this.rowGapInPx / 2);
            parentOffsetRect.left = parentOffsetRect.x =
                this.cardSide === CardSide.RIGHT
                    ? adjacentCardParentOffsetRect.right
                    : adjacentCardParentOffsetRect.left - this.colGapInPx;
            parentOffsetRect.right = parentOffsetRect.left + this.colGapInPx;
            parentOffsetRect.bottom = adjacentCardParentOffsetRect.bottom + (this.rowGapInPx / 2);
            parentOffsetRect.width = parentOffsetRect.right - parentOffsetRect.left;
            parentOffsetRect.height = parentOffsetRect.bottom - parentOffsetRect.top;
            return parentOffsetRect;
          }

          intersectsViewportPoint(viewportPoint) {
            const adjacentCardParentViewportRect = getOffsetParent(this.adjacentCard.element).getBoundingClientRect();
            const parentOffsetPoint = {
              x: viewportPoint.x - adjacentCardParentViewportRect.left,
              y: viewportPoint.y - adjacentCardParentViewportRect.top,
            };

            // Point is above the gap.
            if (parentOffsetPoint.y < this.parentOffsetRect.top) {
              return false;
            }

            // Point is below the gap.
            if (parentOffsetPoint.y > this.parentOffsetRect.bottom) {
              return false;
            }

            // Point is left of the gap.
            if (parentOffsetPoint.x < this.parentOffsetRect.left - this.toleranceInPx) {
              return false;
            }

            // Point is right of the gap.
            if (parentOffsetPoint.x > this.parentOffsetRect.right + this.toleranceInPx) {
              return false;
            }

            return true;
          }

          // TODO(acdvorak): Refactor this function to be easier to understand.
          // TODO(acdvorak): Abstract away LTR logic as much as possible. E.g., foo.getNext
          isAdjacentToDragSource() {
            return this.userDraggedAdjacentCardInCurRow() ||
                   this.userDraggedFirstCardInCurRowToAfterLastCardInPrevRow() ||
                   this.userDraggedLastCardInCurRowToBeforeFirstCardInNextRow();
          }

          userDraggedAdjacentCardInCurRow() {
            // prevent drag to adjacent left || prevent drag to adjacent right
            return this.adjacentCard.isDragSource() || this.prevAdjacentCardInSameRowIsDragSource();
          }

          // LTR: User dragged first card in row (N) to after last card in row (N - 1).
          // TODO(acdvorak): It feels like this function (and everything it calls) should belong to a different class.
          userDraggedFirstCardInCurRowToAfterLastCardInPrevRow() {
            return this.isAdjacentToLastCardInCurRow() && this.nextCardInNextRowIsDragSource();
          }

          // LTR: User dragged last card in row (N) to before first card in row (N + 1).
          // TODO(acdvorak): It feels like this function (and everything it calls) should belong to a different class.
          userDraggedLastCardInCurRowToBeforeFirstCardInNextRow() {
            return this.isAdjacentToFirstCardInNextRow() && this.prevCardInPrevRowIsDragSource();
          }

          prevAdjacentCardInSameRowIsDragSource() {
            // A drop zone attached to the *right* side of a card will always have the same adjacentCard value as its
            // sister drop zone on the *left* side of the same card. As a result, if the user drags the second-to-last
            // card to after the last card in a row, omitting this check would lead to the drag being blocked, which is
            // incorrect behavior.
            if (this.isRightOfCard()) {
              return false;
            }

            const prevCardInSameRow = this.prevCardInSameRow();
            return Boolean(prevCardInSameRow) && prevCardInSameRow.isDragSource();
          }

          isAdjacentToLastCardInCurRow() {
            return this.colIndex === (this.isLTR() ? this.lastIndexInCurRow() : 0);
          }

          isAdjacentToFirstCardInNextRow() {
            return this.colIndex === (this.isLTR() ? 0 : this.lastIndexInCurRow());
          }

          nextCardInNextRowIsDragSource() {
            const nextCardInNextRow = this.nextCardInNextRow();
            const nextCardIsDragSource = Boolean(nextCardInNextRow) && nextCardInNextRow.isDragSource();
            return nextCardIsDragSource && (this.isLTR() ? this.isRightOfCard() : this.isLeftOfCard());
          }

          prevCardInPrevRowIsDragSource() {
            const prevCardInPrevRow = this.prevCardInPrevRow();
            const prevCardIsDragSource = Boolean(prevCardInPrevRow) && prevCardInPrevRow.isDragSource();
            return prevCardIsDragSource && (this.isLTR() ? this.isLeftOfCard() : this.isRightOfCard());
          }

          nextCardInNextRow() {
            const nextRow = this.nextRow();
            return nextRow ? nextRow[this.isLTR() ? 0 : nextRow.length - 1] : null;
          }

          prevCardInPrevRow() {
            const prevRow = this.prevRow();
            return prevRow ? prevRow[this.isLTR() ? prevRow.length - 1 : 0] : null;
          }

          prevCardInSameRow() {
            return this.curRow()[this.colIndex - 1];
          }

          isRightOfCard() {
            return this.cardSide === CardSide.RIGHT;
          }

          isLeftOfCard() {
            return this.cardSide === CardSide.LEFT;
          }

          lastIndexInCurRow() {
            return this.curRow().length - 1;
          }

          curRow() {
            return this.allRows[this.rowIndex];
          }

          nextRow() {
            return this.allRows[this.rowIndex + 1];
          }

          prevRow() {
            return this.allRows[this.rowIndex - 1];
          }

          isLTR() {
            return isLTR(this.adjacentCard.element.parentNode);
          }
        }

        function getColGapInPx(rows) {
          if (rows.length < 1 || rows[0].length < 2) {
            return 0;
          }
          const firstRow = rows[0];
          return firstRow[1].parentOffsetRect.left - firstRow[0].parentOffsetRect.right;
        }

        function getRowGapInPx(rows) {
          if (rows.length < 2) {
            return 0;
          }
          const firstRow = rows[0];
          const secondRow = rows[1];
          return secondRow[0].parentOffsetRect.top - firstRow[0].parentOffsetRect.bottom;
        }

        function getSpacerWidthInPx(cardGroupEl, rows) {
          if (rows.length === 0 || rows[0].length === 0) {
            return 0;
          }

          const firstRow = rows[0];
          const lastCard = firstRow[firstRow.length - 1];

          if (isLTR(cardGroupEl)) {
            // TODO(acdvorak): Don't assume px units
            const lastCardMarginRight = parseInt(getComputedStyle(lastCard.element).marginRight, 10);
            const lastCardRight = lastCard.parentOffsetRect.right + lastCardMarginRight;
            const cardGroupRight = cardGroupEl.getBoundingClientRect().right;
            return cardGroupRight - lastCardRight;
          } else {
            // TODO(acdvorak): Don't assume px units
            const lastCardMarginLeft = parseInt(getComputedStyle(lastCard.element).marginLeft, 10);
            const lastCardLeft = lastCard.parentOffsetRect.left + lastCardMarginLeft;
            const cardGroupLeft = cardGroupEl.getBoundingClientRect().left;
            return lastCardLeft - cardGroupLeft;
          }
        }

        function getPointerPositionInViewport(e) {
          const originalEvent = e.originalEvent;
          const nativePointerEvent = originalEvent.touches ? originalEvent.touches[0] : originalEvent;
          return {
            x: nativePointerEvent.clientX,
            y: nativePointerEvent.clientY,
          };
        }

        function getCards(e) {
          const cardGroupEl = e.originalSource.closest('.m2-card-group');
          const cardEls = [].slice.call(cardGroupEl.querySelectorAll('.m2-card'));
          const cards = cardEls
            .map(Card.create)
            .filter(Card.isVisible)
            .sort(Card.orderByCoordinate);

          const rowBuckets = new Map();
          cards.forEach((card) => {
            const top = card.parentOffsetRect.top;
            if (!rowBuckets.has(top)) {
              rowBuckets.set(top, []);
            }
            rowBuckets.get(top).push(card);
          });

          const rows = [];
          rowBuckets.forEach((row) => {
            rows.push(row);
          });

          return {cardGroupEl, cards, cardEls, rows};
        }

        function getDropZones(e, {rowGapInPx, colGapInPx} = {}) {
          const {rows} = getCards(e);

          const dropZones = [];
          rows.forEach((curRow, rowIndex) => {
            curRow.forEach((curCardInRow, colIndex) => {
              function createDropZone(cardSide) {
                return new DropZone({
                  adjacentCard: curCardInRow,
                  cardSide,
                  toleranceInPx: curCardInRow.parentOffsetRect.width / 2,
                  rowGapInPx,
                  colGapInPx,
                  allRows: rows,
                  rowIndex,
                  colIndex,
                });
              }
              dropZones.push(createDropZone(CardSide.LEFT));
              if (colIndex === curRow.length - 1) {
                dropZones.push(createDropZone(CardSide.RIGHT));
              }
            });
          });

          return dropZones;
        }

        function getDropZone(e, dropZones) {
          const pointerPositionInViewport = getPointerPositionInViewport(e);
          for (let curDropZone of dropZones) {
            if (curDropZone.intersectsViewportPoint(pointerPositionInViewport)) {
              if (curDropZone.isAdjacentToDragSource()) {
                return null;
              }
              return curDropZone;
            }
          }
          return null;
        }

        var interval = setInterval(() => {
          if (getComputedStyle(document.querySelector('.hero')).position === 'relative') {
            clearInterval(interval);
            init();
          }
        }, 200);

        function insertAdjacentElement(refEl, newEl, cardSide) {
          let relPos;
          if (isLTR(refEl.parentNode)) {
            relPos = cardSide === CardSide.LEFT ? 'beforebegin' : 'afterend';
          } else {
            relPos = cardSide === CardSide.LEFT ? 'afterend' : 'beforebegin';
          }
          refEl.insertAdjacentElement(relPos, newEl);
        }

        // NOTE(acdvorak): This code assumes:
        // 1. ALL CARDS ARE THE SAME SIZE
        // 2. HORIZONTAL AND VERTICAL MARGINS BETWEEN CARDS ARE IDENTICAL
        function init() {
          var cards = document.querySelectorAll('.m2-card');
          for (var i = 0; i < cards.length; i++) {
            let card = cards[i];
            // TODO(acdvorak): This is gross
            card.ripple = mdc.ripple.MDCRipple.attachTo(card);
          }

          const draggable = new Draggable.Draggable(document.querySelectorAll('.demo-card-group'), {
            draggable: '.m2-card',
            delay: 200,
            classes: {
              'container:dragging': 'm2-card-group--dragging',
              'source:dragging': 'm2-card--drag-source',
              'mirror': 'm2-card--drag-mirror',
            },
          });

          const dropZoneElDummyParent = document.createElement('div');
          dropZoneElDummyParent.innerHTML = `
<div class="m2-card-drop-spacer"></div>
<div class="m2-card-drop-zone"></div>
          `.trim();
          const dropSpacerEl = dropZoneElDummyParent.children[0];
          const dropZoneEl = dropZoneElDummyParent.children[1];

          let colGapInPx;
          let rowGapInPx;
          let dropZones;
          let dropZone;
          let sourceCardEl;
          let spacerWidthInPx;

          function resetCardOffsets(cards) {
            cards.forEach((card) => card.offsetX = 0);
            dropSpacerEl.remove();
            dropZoneEl.remove();
          }

          draggable.on('drag:start', (e) => {
            const {cardGroupEl, rows} = getCards(e);

            colGapInPx = getColGapInPx(rows);
            rowGapInPx = getRowGapInPx(rows);
            dropZones = getDropZones(e, {rowGapInPx, colGapInPx});
            dropZone = null;
            sourceCardEl = e.originalSource;
            spacerWidthInPx = getSpacerWidthInPx(cardGroupEl, rows);
          });

          draggable.on('drag:move', (e) => {
            const {cardGroupEl, cards, rows} = getCards(e);
            dropZone = getDropZone(e, dropZones);

            resetCardOffsets(cards);

            e.originalEvent.preventDefault();

            if (dropZone) {
              insertAdjacentElement(dropZone.adjacentCard.element, dropZoneEl, dropZone.cardSide);
              const isFirstRow = dropZone.rowIndex === 0;
              const needsSpacer = isLTR(cardGroupEl)
                ? dropZone.colIndex === 0
                : dropZone.colIndex === rows[dropZone.rowIndex].length - 1 && dropZone.cardSide === CardSide.RIGHT;
              if (!isFirstRow && needsSpacer) {
                insertAdjacentElement(dropZoneEl, dropSpacerEl, dropZone.cardSide);
              } else {
                dropSpacerEl.remove();
              }

              const curRow = rows[dropZone.rowIndex];
              curRow.forEach((curCardInRow, curCardInRowColIndex) => {
                const isRightSide = dropZone.cardSide === CardSide.RIGHT;
                const multiplier = isRightSide || curCardInRowColIndex < dropZone.colIndex ? -1 : +1;
                curCardInRow.offsetX = multiplier * (dropZone.colGapInPx / 2);
              });
            } else {
              dropSpacerEl.remove();
              dropZoneEl.remove();
            }
          });

          draggable.on('drag:stop', (e) => {
            const {cards} = getCards(e);

            resetCardOffsets(cards);

            if (dropZone) {
              const adjacentCardEl = dropZone.adjacentCard.element;
              const dragSourceEl = e.originalSource;
              const cardSide = dropZone.cardSide;
              setTimeout(() => {
                insertAdjacentElement(adjacentCardEl, dragSourceEl, cardSide);
              });
            }

            if (sourceCardEl.ripple) {
              // TODO(acdvorak): Submit PR to "draggable" repo to pass through originalEvent to drag:stop
              // TODO(acdvorak): Submit PR to "draggable" repo to listen for ESC key
//              sourceCardEl.ripple.deactivate(e.originalEvent);

              // TODO(acdvorak): Submit PR to fix Ripple so that it doesn't require an event object
              sourceCardEl.ripple.deactivate({type: 'pointerup'});
            }

            colGapInPx = null;
            rowGapInPx = null;
            dropZones = null;
            dropZone = null;
            sourceCardEl = null;
            spacerWidthInPx = null;
          });
        }
      })();
    </script>
  </body>
</html>
